<?php
/**
 * @file
 * Code for the HPS Encyclopedia feature.
 */

include_once 'hps_encyclopedia.features.inc';

/**
 * Implements hook_views_pre_render().
 */
function hps_encyclopedia_views_pre_render(&$view) {

  foreach ($view->result as $delta => &$row) {

    // @note We pull all bistream URLs from DSpace into a multi-value field
    //       but we don't want to show all of them when displaying the
    //       dspace_bitstream_url field in views. For now we only want to use
    //       PDFs and video/audio URLs in views. Since dspace_bitstream_url is a
    //       multi-value field all URLs are rendered together with a single set
    //       of views field options. This is not ideal. Ideally we want different
    //       views field settings depending on the mimetype. The following
    //       attempts to address that.
    if (property_exists($row, 'field_dspace_bitstream_url')) {

      $media = array();
      foreach ($row->field_dspace_bitstream_url as $b => $bitstream) {
        // Skip if we don't have raw data.
        // @note Make sure 'Use field template' is unchecked in view so we get
        //       render element and raw data.
        if (!isset($bitstream['raw'])) continue;
        $mimetype = file_get_mimetype($bitstream['raw']['url']);
        if (_is_pdf($mimetype)) {
          $row->field_dspace_bitstream_url[$b]['rendered']['#element']['title'] = t('Download PDF');
          $row->field_dspace_bitstream_url[$b]['rendered']['#element']['attributes']['class'] = 'pdf';
        }
        elseif (hps_media_is_mimetype_supported($mimetype)) {
          $media[$b] = $bitstream['rendered']['#element']['url'];
          // Add pre render hook so we can force audio/video bitstreams to use
          // field template
          //$row->field_dspace_bitstream_url[$b]['rendered']['#pre_render'][] = '_hps_encyclopedia_pre_render_bitstream';
        }
        else {
          $row->field_dspace_bitstream_url[$b]['rendered']['#access'] = FALSE;
        }
      }

      if (!empty($media)) {
        $field_alias = $view->field['dspace_bitstream_url']->field_alias;
        $entity      = $row->_field_data[$field_alias]['entity'];
        $entity_type = $row->_field_data[$field_alias]['entity_type'];
        $field       = field_view_field($entity_type, $entity, 'dspace_bitstream_url');
        $field['#label_display'] = 'hidden';
        foreach ($media as $b => $url) {
          // Add pre render hook for audio/video bitstreams and pass field data
          $row->field_dspace_bitstream_url[$b]['rendered']['#pre_render'][] = '_hps_encyclopedia_pre_render_bitstream';
          $row->field_dspace_bitstream_url[$b]['rendered']['#bitstreams'] = $field;
        }
      }

    }


    // Alter rendered creator string.
    if (property_exists($row, 'field_dc_creator')) {
      // Get the raw values from the original entity
      // see views_handler_field_field::get_value()
      $creators = $view->field['dc_creator']->get_value($row);
      foreach ($creators as $i => $creator) {
        // It's a multivalue field so we expect an array with a value index and
        // matching rendered values
        if (!isset($creator['value']) || !isset($row->field_dc_creator[$i]['rendered'])) continue;

        // If the Views field style setting 'Use field template' is TRUE
        // then we get a rendered string, otherwise we get a generic render
        // #markup element. Convert rendered string into render element for
        // consistency, then insert new value.
        if (is_string($row->field_dc_creator[$i]['rendered'])) {
          $view->result[$delta]->field_dc_creator[$i]['rendered'] = array();
        }
        // Reverse names if commas exist in creator. Ignore dates or anything
        // after second comma. Examples
        //     - Brode, Howard Stidham (1890-1958) => Howard Stidham Brode
        //     - Huettner, Alfred F. (Alfred Francis), b. 1884 => Alfred F. (Alfred Francis) Huettner
        //     - Coolidge, Baldwin, 1845-1948 => Baldwin Coolidge
        // @note Alternative option for multiple commas:
        //       Reverse all parts:
        //       implode(' ', array_reverse(explode(', ', $creator['value'])));
        //       Move the first part to the end with a regular expression:
        //       preg_replace('/^([^,]*),\s*(.*)$/', '$2 $1', $creator['value']);

        // Reverse first two parts of comma seperated string
        $parsed_creator = implode(' ', array_reverse(array_slice(explode(', ', $creator['value']), 0, 2, TRUE)));
        // Remove dates from string
        $parsed_creator = preg_replace('/\s[(]?\d{1,4}-?\d{1,4}[)]?/','', $parsed_creator);
        // Correct badly split commas in parentheses.
        // @note Assumes appending on end is correct fix e.g.
        //       "Marine Biological Laboratory (Woods Hole, Mass.)"
        //       incorrectly split to:
        //       "Mass.) Marine Biological Laboratory (Woods Hole"
        //       so reverse comma split:
        if (preg_match('/^[^(]*?\)/', $parsed_creator, $matches)) {
          $parsed_creator = trim(str_replace($matches[0], '', $parsed_creator)) . ", $matches[0]";
        }
        $view->result[$delta]->field_dc_creator[$i]['rendered']['#markup'] = $parsed_creator;
        unset($parsed_creator);
      }
    }
  }
}

/**
 * Pre render callback for media bitstream fields.
 *
 * @note Called from drupal_render.
 *
 * @param $element
 *   Array containg renderable element for a single value in a multi-value
 *   dspace_bitstream_url from views.
 * @return
 *   Array containing the markup of the rendered field using core field
 *   templates.
 */
function _hps_encyclopedia_pre_render_bitstream($element) {

  if (!isset($element['#bitstreams'])) return;

  $field = $element['#bitstreams'];
  foreach ($field['#items'] as $delta => $bitstream) {
    // Remove other bitstream elements before rendering our element
    if ($bitstream['url'] != $element['#element']['url']) {
      unset($field['#items'][$delta]);
      unset($field[$delta]);
    }
  }
  // Render field and return to drupal_render for output
  return array(
    '#children' => render($field)
  );
}



/**
 * Helper function to determine if the bistream is a PDF
 */
function _is_pdf($mimetype) {
  return in_array($mimetype, array('application/pdf'));
}

